/**
 * !! File automatically generated through code.
 * 
 * Do NOT edit this file manually, it will be overriden after the next script reload!
 * 
 */

#include "Serializer.h"

#include "CppHeaderParser.h"
{{INCLUDE_HEADERS}}
/**
 * Template(HEADER_PATH):
 *
 * #include "..\|HEADER_PATH|"
 *
 */

using namespace component;

typedef std::map<std::string, std::vector<SerializedField>> SerializedClassFields;

const std::vector<SerializedField>& Serializer::GetSerializedFieldsForClass(const std::string& className)
{
    static const SerializedClassFields serializedClassFields = {
        // The empty string is necessary
        {"", std::vector<SerializedField>{}},
{{SERIALIZED_CLASS_FIELDS}}
        /**
         * Template(CLASS_NAME, SERIALIZED_FIELD[]):
         *
         * {"|CLASS_NAME|", std::vector<SerializedField>{||FOR_EACH SERIALIZED_FIELD|| {"|SERIALIZED_FIELD.ATTRIBUTE_NAME|", FieldType|SERIALIZED_FIELD.TYPE|} ||END_FOR_EACH||}},
         *
         */
    };

    // Try to find the class
    const auto it = serializedClassFields.find(className);
    if (it != serializedClassFields.end())
        return it->second;

    return serializedClassFields.find("")->second;
}

void* Serializer::GetAttributeReference(Component* instance, const std::string& attributeName)
{
{{ATTRIBUTE_RESOLVER}}
    /**
     * Template(CLASS_NAME, ATTRIBUTE_NAME[]):
     *
     * if (dynamic_cast<|CLASS_NAME|*>(instance) != nullptr)
     * {
     *      |CLASS_NAME|* obj = dynamic_cast<|CLASS_NAME|*>(instance);
     *
     *      ||FOR_EACH ATTRIBUTE_NAME||
     *      if (attributeName == "|ATTRIBUTE_NAME|")
     *          return &obj->|ATTRIBUTE_NAME|;
     *
     *      ||END_FOR_EACH||
     *      return nullptr;
     * }
     *
     */

    return nullptr;
}
