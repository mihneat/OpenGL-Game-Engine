/**
 * !! File automatically generated through code.
 * 
 * Do NOT edit this file manually, it will be overriden after the next script reload!
 * 
 */

#include "Serializer.h"

#include "CppHeaderParser.h"
{{INCLUDE_HEADERS}}
/**
 * Template(HEADER_PATH):
 *
 * #include "..\|HEADER_PATH|"
 *
 */

using namespace component;

typedef std::map<std::string, std::vector<SerializedField>> SerializedClassFields;

const std::vector<SerializedField>& Serializer::GetSerializedFieldsForClass(const std::string& className)
{
    static const SerializedClassFields serializedClassFields = {
        // The empty string is necessary
        {"", std::vector<SerializedField>{}},
{{SERIALIZED_CLASS_FIELDS}}
        /**
         * Template(CLASS_NAME, SERIALIZED_FIELD[]):
         *
         * {"|CLASS_NAME|", std::vector<SerializedField>{||FOR_EACH SERIALIZED_FIELD|| {"|SERIALIZED_FIELD.ATTRIBUTE_NAME|", FieldType|SERIALIZED_FIELD.TYPE|} ||END_FOR_EACH||}},
         *
         */
    };

    // Try to find the class
    const auto it = serializedClassFields.find(className);
    if (it != serializedClassFields.end())
        return it->second;

    return serializedClassFields.find("")->second;
}

void* Serializer::GetAttributeReference(Component* instance, const std::string& attributeName)
{
{{ATTRIBUTE_RESOLVER}}
    /**
     * Template(CLASS_NAME, ATTRIBUTE_NAME[]):
     *
     * if (dynamic_cast<|CLASS_NAME|*>(instance) != nullptr)
     * {
     *      |CLASS_NAME|* obj = dynamic_cast<|CLASS_NAME|*>(instance);
     *
     *      ||FOR_EACH ATTRIBUTE_NAME||
     *      if (attributeName == "|ATTRIBUTE_NAME|")
     *          return &obj->|ATTRIBUTE_NAME|;
     *
     *      ||END_FOR_EACH||
     *      return nullptr;
     * }
     *
     */

    return nullptr;
}

Component* Serializer::ComponentFactory(const std::string& className, transform::Transform* parent)
{
{{COMPONENT_FACTORY}}
    /**
     * Template(CLASS_NAME):
     *
     * if (className == "|CLASS_NAME|") return new |CLASS_NAME|(parent);
     * 
     */
    
    return nullptr;
}

const std::vector<std::string>& Serializer::GetSerializedClasses()
{
    static const std::vector<std::string> classNames = {{{GET_CLASS_NAMES}}};
    /**
     * Template(CLASS_NAME):
     *
     * "|CLASS_NAME|",
     * 
     */
    
    return classNames;
}

const std::vector<std::pair<std::string, int>>& Serializer::GetValuePairsForEnum(const std::string& enumName)
{
    static const std::unordered_map<std::string, std::vector<std::pair<std::string, int>>> enumPairs = {
        {"", {}},
{{ENUM_VALUE_PAIRS}}
        /**
         * Template(ENUM_NAME, ENUM_VALUES[])
         *
         * {"|ENUM_NAME|", {||FOR_EACH ENUM_VALUES||{"|.NAME|", |.INDEX|}, ||END FOR_EACH||}}
         *
         */
    };

    // Try to find the enum
    const auto it = enumPairs.find(enumName);
    if (it != enumPairs.end())
        return it->second;

    return enumPairs.find("")->second;
}
