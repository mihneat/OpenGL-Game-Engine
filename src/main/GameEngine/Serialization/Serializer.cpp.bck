#include "Serializer.h"

#include "CppHeaderParser.h"
#include "../src/main/GameEngine/ComponentBase/Components/Logic/Objects/Obstacle.h"

/**
 * Template(HEADER_PATH):
 *
 * #include "..\|HEADER_PATH|"
 *
 */

using namespace component;

typedef std::map<std::string, std::vector<SerializedField>> SerializedClassFields;

const std::vector<SerializedField>& Serializer::GetSerializedFieldsForClass(const std::string& className)
{
    static const SerializedClassFields serializedClassFields = {
        // TODO: REMOVE HARDCODE AND GENERATE SERIALIZATION THROUGH PARSER
        // TODO: Here are some examples
        // The empty string is necessary
        {"", std::vector<SerializedField>{}},
        {"Obstacle", std::vector<SerializedField>{{"collisionRadius", FieldTypeFloat}, {"isHazard", FieldTypeBool}}},
        {"GroundStick", std::vector<SerializedField>{}},

    /**
     * Template(CLASS_NAME, SERIALIZED_FIELD[]):
     *
     * {"|CLASS_NAME|", std::vector<SerializedField>{||FOR_EACH SERIALIZED_FIELD|| {"|SERIALIZED_FIELD.ATTRIBUTE_NAME|", |SERIALIZED_FIELD.TYPE|} ||END_FOR_EACH||}},
     *
     */
    };

    // Try to find the class
    const auto it = serializedClassFields.find(className);
    if (it != serializedClassFields.end())
        return it->second;

    return serializedClassFields.find("")->second;
}

void* Serializer::GetAttributeReference(Component* instance, const std::string& attributeName)
{
    // This will ALL be generated by the parser!!
    if (dynamic_cast<Obstacle*>(instance) != nullptr)
    {
        Obstacle* obj = dynamic_cast<Obstacle*>(instance);

        if (attributeName == "collisionRadius")
            return &obj->collisionRadius;

        if (attributeName == "isHazard")
            return &obj->isHazard;

        return nullptr;
    }
    
    if (dynamic_cast<GroundStick*>(instance) != nullptr)
    {
        GroundStick* obj = dynamic_cast<GroundStick*>(instance);

        return nullptr;
    }

    /**
     * Template(CLASS_NAME, ATTRIBUTE_NAME[]):
     *
     * if (dynamic_cast<|CLASS_NAME|*>(instance) != nullptr)
     * {
     *      |CLASS_NAME|* obj = dynamic_cast<|CLASS_NAME|*>(instance);
     *
     *      ||FOR_EACH ATTRIBUTE_NAME||
     *      if (attributeName == "|ATTRIBUTE_NAME|")
     *          return &obj->|ATTRIBUTE_NAME|;
     *
     *      ||END_FOR_EACH||
     *      return nullptr;
     * }
     *
     */

    return nullptr;
}
